    1)Что придумали майки
В общем-то, они реализовали для всех коллекций этот паттерн

    2) Вопросы по енумераторам
а) Что за new в интерфейсе (это необязательное слово, оно нужно для того, 
чтобы обозначить свои намерения использовать именно этот интерфейсный метод)
б) Почему есть objectы (поддержка легаси кода)
в) Зачем итератору dispose

    3) После того как сделали май лист 
Можно рассказать про то, что теперь мы можем пользоваться foreach
Нужно показать, что это простой случай. Но на самом деле мы можем делать
с этим много интересных вещей. Если у нас есть граф, то мы бы могли написать
свой итератор таким образом, чтобы он осуществлял поиск в глубину или ширину
например.
Рассказать про то, что форич генерирует тотже самы код с мув некстами
и current.
Потом нужно рассказать про duck typing. Смысл его в том, IEnumerable<int>
у нас будет возвращаться структура IEnumerator<int> по интерфейсу!!!, а не 
List<int>.Enumerator. И в первом случае структура кастуется к интерфейсу,
а значит что происходит (вопрос про боксинг), во втором случае у нас просто
возвращается структура. Можно показать Enumerator из референсов.
https://source.dot.net/#System.Private.CoreLib/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/List.cs,d3661cf752ff3f44

    4) Смешной пример
(вопрос что будет на экране, если не допрут то пояснить что все из-за того
что структура в первом случае за боксилась и мы получаем не велью а референсов
и у нас все происходит ок, в другом случае у нас велью, и при обращении
к итемс у нас создается копия этой штуки). После рассказать про то, что упорно долго
думали и поэтому вообще решили за дак тайпить все ето дело, потому что
перформанс. Но дак тайпинг это плохо, как и изменяемые структуры. Поэтому лучше
самостоятельно так не делать.

    5) Генераторы
Инициализация итератора, нужно рассказать о том, что вызывая GetEnumerator,
мы обнуляем его до исходного состояния, если он не использовался где-то еще,
либо возвращаем новый итератор. Также нам еще отрубают возможность использовать 
его из разных потоков, чтобы предотвратить проблемы с потокобезопасностью.

private static IEnumerable<int> Fibonacci(int count)
Тут появляется непонятная -2, и у вас должен возникнуть вопрос,
что это такое. На самом деле, генерация кода заключается в том,
чтобы превратить наш итератор в некоторое подобие машины состояния.
Тут все работает исходя из machineState, который символизирует 
различные состояния нашего енумератора.
-2 Не ициализирована
-1 Инициализирована
0 В процессе обхода
1 Закончила обход.

В конце нужно сказать, что как видите, это очень сложная штука,
а объясняю вам ее потому что, она поможет вам осознать как устроены
механизмы работы ассинхронного выполнения, в которых разобраться
намного сложнее.
