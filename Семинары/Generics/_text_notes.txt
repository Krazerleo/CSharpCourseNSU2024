    1) Про ошибку + в дженерик методе. 
В плюсах бы это работало бы, так как там он фактические просто подставляет тип аргумента в шаблон.
Если типы не обладают каким-то свойством после подстановки в шаблон, то только тогда шаблон валится с ошибкой компиляции.
Причем с очень длинным стеком ошибки почти всегда.

В шарпах дженерики работают по другому. Изначально тип, подставляемый в дженерик рассматривается как базовый, то есть
System.Object. И у него есть только стандартных четыре метода (спросить что это за методы).

В чем тогда их смысл, спросите вы. А смысл в том, что можно на дженерик наложить ограничения, например, то что он реализует
некоторый интерфейс. Попробуем поправить этот момент.

    2) Как работают дженерики
Так как все компилируется в рантайме JIT компилятором, то генерируются классы и методы только для используемых параметров.
Так же когда сам дженерик метод/класс встречается несколько раз, то полученный код кэшируется.
Для значимых типов должны совпадать еще и сам тип обобщенного объекта для успешного кэширования.

Рассказать почему не может вывести тип. На самом деле может, но возможно не так, как хотел бы разработчик.

    3) Подводные камни
а) Может быть структура, а структура не может быть null, можно починить default
б) Структура и так по умолчанию имеет new(), и проблем как бы нет, но почему-то выскакивает ошибка, что нельзя их использовать оба.
   Как по мне, так лучше бы написали бы, что структура и так по умолчанию реализует new().
в) Не может наследоваться от 2 классов (множественное наследование запрещено)