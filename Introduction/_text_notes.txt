Начало: Мы не будем заострять внимание на каких-то простых вещах, которые есть в других 
языках программирования типа переменных, условий и циклов. Поэтому мы начнем с особенностей
шарпов.

Сначала мы разберемся с полной иерархией нашего решения.

Solution: Солюшен можем быть только один, и по своей сути он просто объединяет множество
крупных единиц трансляций если их так можно назвать, которые называются проектами.

Project: Проектом можно считать крупную единицу трансляции. Не смотря на то, что он может
лежать вместе с другим проектом в одном солюшене, он все равно является изолированным от 
других проектов по умолчанию. Чтобы можно было ссылаться на код из другого проект нужно 
ручками добавлять ссылки на интересующий нас проект. Сделать это можно, если подредактировать 
файл проекта. Во время компиляции проект превращается в сборку (Assembly), которая по своей 
сути является dllкой. Понятие статической библиотеки так таковое отсутствует, как и 
статическая линковка, если не использовать стороннии средства.

Nuget пакеты:
При нормальной разработке часто бывает нужно запилить функционал, который точно был кем-то
уже сделан. В таком случае используют стороннии библиотеки, при условии что они конечно есть.
Чтобы внедрить эти библиотеки (или пакеты как их в дотнете называют) используются менеджеры
пакетов, и в случае дотнета им выступает нагет. Пользоваться им просто, просто выбираете нужный
проект, в ide нажимаете у проекта кнопочку нугет, вбиваете имя нужной либы и он по воздуху сам
подтянет пакет, а также и сами зависимости пакета.

Простые Файлы: простые файлы могут лежать как в солюшене, так и в самих проектах. Под простыми
файлами подразумеваются те, которые не входят в этап компиляции, как например конфиги,
мультимедиа, возможно сторонние дллки, которые подключаются уже на уровне пользователя.

Далее: проект содержит в себе в общем случае файлы с расширением .cs. Ну или папки с кодом
или другие папки . В этих файлах мы как раз и пишем свой код. Они являются базовой единицей 
трансляции. Теперь перейдем к более техническим деталям. Начнем с классов и структур.

Using/Namespace: Рассказать что делают. Зачем это надо? Чтобы можно было аккуратно разложить
код по полочкам. Если не использовать неймспейсы то проект превращается в горящую помойку.
С какой-то версии с# можно без фигурных скобок писать, и если есть такая возможность то лучше
так и пишите.

Classes: первое что рассмотрим это модификаторы доступа класса

* internal - очень часто применяется при создании библиотеки, которая будет использована В
дальнейшем. По своей сути инкапсуляция на уровне сборки. Без этого бы у нас в интелисенс 
лезли бы все кишки кучи либ, которые у нас юзаются.

* sealed - нужен в основном для того, чтобы не дать возможность унаследоваться и что-то
сломать.

* partial - очень редко нужен, если только вы не используете кодогенерацию в своем проекте.
Как пример, WPF который по xaml разметке генерирует паршиал класс со всей логикой. А если
нам нужно поправить где-то логику, то мы ее дополняем в партиашл классе.

Поля и свойства: протектед интернал и ... не видел вообще нигде, и в целом использование
модификатора протектед для полей в дотнете считается моветоном. const - поддерживают только
базовые типы вроде чисел, чаров и строк. Но можно обойтись static readonly.

Свойства: на самом деле свойства это просто функции геттера и сеттера, которые генерерятся
при сборке проекта. Генерируются функции, а также само поле (backing field). * Рассказать 
про примеры* (More restrictive 3 ex, Better Protected 5 ex)

Методы: abstract - при наследовании мы должны их обязательно определить (либо сделать 
сам класс тоже абстрактным). static - статические методы, могут использовать только 
статические методы и поля\свойства. new - лучше так не делать, так как может запутаться.
Можно и с не виртуальными функциями юзать.

Так как свойства по своей сути тоже функции, то модификаторы для методов также работают.
Но я как то не видел еще чтобы свойства было абстрактным.

Интерфейсы: интерфейсы в шарпах нужны для того, чтобы установить тот факт, что реализация
реализует тот контракт, который установлен в интерфейсе. Эта возможность помогает нам
абстрагироваться от конкретной реализации класса, то есть напрямую сказать, мне неважно, как
ты это делаешь, мне важно что ты делаешь.

Многие из вас надеюсь помнят еще плюсы, и зададутся вопросом, а чем это интерфейс отличается
от абстрактных классов. Главным образом тем, что в шарпах нет множественного наследования от
классов (абстрактный класс это тоже класс). А наследоваться от интерфейсов можно хоть сколько
угодно, но они не обладают теми возможностями, которые есть у абстрактных классов.

Про default implementation:

Нужна для того, чтобы можно было не вводить изменения в API. Но есть очень много подвохов.
Лучше не применять в сложной иерархии наследования. А если будете применять, то перечитайте
статью выше.

Про расположение в памяти: Классы и интерфейсы всегда располагаются в куче. Поэтому, чтобы
не нагружать гц, по возможности не создавайте экзэмпляры классов лишний раз. Если ваш класс
не содержит в себе какие-то данные, то лучше сделайте его методы статическими как пример.

Про object: Все классы неявным образом наследуются от object. Сам object это довольно большая
структура, которая содержит указатель на таблицу методов (methodTable+TypeInfo). Также у нее
есть еще хедерок, который содержит в себе кучу разной инфы для сборщика мусоров, битики для
механизма синхронизации и многое другое. Соответственно, все классы также хранят эту инфу.

Если рассматривать object с точки зрения практически, то у него есть 3 виртуальных метода:
Equals, GetHashCode, ToString. 

Если от пользовательского типа требуется хэшкод, то лучше определите его сами, так как 
реализация по дефолту имеет импакт на производительность. И в таком случае переопределите
метод Equals, чтобы он задействовал ваш хэш (равны хэши != равны объекты).

Еще у object есть метод GetType, через который мы можем в рантайме получить инфу про экзэмпляр
класса, и делать всякие рефлективные штуки, но об этом в другой раз.

Теперь поговорим о структурах: структуры, в отличии от классов, могут располагаться прямо
на стеке. Также у них особая семантика, а именно то, что при передаче в метод, они полностью
копируются. Нужно также понимать, что при копировании ссылочного типа из структуры копируется
только ссылка, а не сам объект по ссылке.

Также еще отметить, что структуры нельзя наследовать (спросить почему). Но можно навешивать
интерфейсы, но иногда это может выйти боком.

Интересный факт, сама сама структура унаследована от System.ValueType, который уже унаследован
от System.Object. Поэтому в структурах можно переопределять методы System.Object.
Есть еще классификация структур по managed и unmanaged. В основном сделано для того, чтобы
можно было быстро передать куда-нибудь данные в сыром виде. Как пример можно рассказать про
dots. Зачем я это рассказываю, просто для unmanaged структур оператор Equals использует 
эффективный алгоритм сравнения, проще говоря (memcmp). Хотя это не всегда работает из 
мемори лэйаута.

Boxing / Unboxing: как было ранее сказано, структуры наследуются от object. Но если они 
наследуются от него, то тогда в целом ломается логика работы со стеком. Вот пример есть.
Про безопасность языка рассказать.

На самом деле это работает не только при касте к object. А вообще с любым кастом.
А также с reference conversion (так как мы не знаем размер типа значения, то мы не можем с 
ним работать как с значимым типом)

На грабли: Показать как работают ссылки. Сделать отсылку на модификатор ref.

Enum: рассказать про битовые флаги. 